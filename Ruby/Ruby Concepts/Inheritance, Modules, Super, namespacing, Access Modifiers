------------------- Inheritance vs Modules --------------------

Ruby has two primary ways to implements inheritance.

a.) Class Inheritance (Traditional Way)

b.) Interface Inheritance (Mixin Modules comes in Picture)

* Class Inheritance is when a class inherits behavior from another class. The class that is inheriting behavior is called the subclass and the class it inherits from is called the superclass.If the same function/method name defined under child class ruby checks the object's class first for the method before it looks in the superclass.

=> Refer Program inheritance_super.rb for more clearance.

* Interface inheritance : This is where mixin modules come into play. The class doesn't inherit from another type, but instead inherits the interface provided by the mixin module.

Module comes in view to work on DRY Concept and module must be constant i.e starts with UPPERCASE.

=> Refer Program modules.rb for more clearance.


------------------- Where to use class inheritance and Modules ------------------

a.) We can only sub class (class inheritance) from one class.On the other hand we can mix in as many modules (interface inheritance).

b.) If there's an "is-a" relationship, class inheritance is usually the correct choice. If there's a "has-a" relationship, interface inheritance is generally a better choice.

c.) We cannot instantiate modules (i.e., no object can be created from a module). Modules are used only for namespacing and grouping common methods together.


------------------- super --------------------

a.) super + : super + defined to invoke instance method from parent class. Now method called is from Parent Class.

b.) super : when we define only super it takes arguments values under name, subject and automatically invoke to initialize method specified under parent class.

c.) super(arg1) : It performs the same function as above and passing values to parent class.

d.) super () : It is used when the super class initialize has no arguments at all.

=> Refer Program inheritance_super.rb for more clearance.

------------------- Method Lookup - How it Works --------------------

Lets understand with example

module P_Training
  def p_training
  end
end

module S_Training
  def s_training
  end

module T_Training
  #def t_training
  #end
end

module 

class Professor 
  include P_Training      
  include T_Training
  attr_accessor :name, :department
  def initialize (name,department)
    self.name = name
    self.department = department
  end
end

Ranjit.t_training - How ruby searches for t_training ?

a.) Professor
b.) P_Training
c.) S_Training
c.) T_Trainin - Here it finds method 
    Lets omit the method under T_training
d.) Object
e.) Kernal
f.) BasicObject

Find method nowhere throw an no method error

------------------- namespacing Modules --------------------

namespacing means organizing similar classes under a module. We will use modules to group related classes.

Lets Understand with example

module Department
  class Subject
    def check_subject
      puts "Physics"
    end
  end

  class Professor
    def professor_name
    end
  end
end

Physics = Department::Subject.new
Lapsu = Department::Professor.new

------------------- Access Modifiers ---------------------

Method Access Control - It is generally implemented through the use of access modifiers. The purpose of access modifiers is to allow or restrict access to a particular thing.

Access Modifiers - Public / Private / Protected methods

a.) Public methods - Open for anyone and we can call these methods outside the class.

b.) Private methods - These can access from other methods only inside the class and then we can call that specific method from outside the class.

c.) Protected methods - It's in between approach between public and private.

    From Inside the class - protected methods are accessible just like public methods.

    From Outside the class - protected methods act just like private methods.

=> Refer Program access_modifiers.rb for more clearance.

















